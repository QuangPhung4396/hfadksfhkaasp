// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios15.6 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name QRoot
import AVFAudio
import AVFoundation
import AVKit
import CommonCrypto
import Compression
import CoreMedia
import DeveloperToolsSupport
import Foundation
import MediaPlayer
@_exported import QRoot
import SDWebImage
import SnapKit
import Swift
import SwiftUI
import Toast_Swift
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
extension UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency public func alertNotice(message: Swift.String? = nil)
  @_Concurrency.MainActor @preconcurrency public func alertWarning(message: Swift.String? = nil)
  @_Concurrency.MainActor @preconcurrency public func alertError(message: Swift.String? = nil)
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency public func alertNotLink(onReport: @escaping () -> Swift.Void, onShowServer: @escaping () -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency public func alertEmptyLink(onReport: @escaping () -> Swift.Void)
}
extension Swift.Array where Element : Swift.Equatable {
  public mutating func remove(object: Element)
  public mutating func appendUnduplicate(object: Element)
  public func indexOf(object: Element) -> Swift.Int?
  public subscript(index index: Swift.Int) -> Element? {
    get
  }
}
extension Swift.Array where Element : Swift.Comparable {
  public func containsElements(as other: [Element]) -> Swift.Bool
}
extension ObjectiveC.NSObject {
  public var identify: Swift.String {
    get
  }
  public static var identify: Swift.String {
    get
  }
}
extension UIKit.UITableView {
  @_Concurrency.MainActor @preconcurrency public func register<T>(cell: T.Type) where T : UIKit.UITableViewCell
  @_Concurrency.MainActor @preconcurrency public func registerXib(_ cell: UIKit.UITableViewCell.Type)
  @_Concurrency.MainActor @preconcurrency public func dequeueReusableCell<T>(for type: T.Type, for indexPath: Foundation.IndexPath) -> T where T : UIKit.UITableViewCell
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func fillSuperview()
  @_Concurrency.MainActor @preconcurrency public func constraintLayout(_ top: UIKit.NSLayoutYAxisAnchor? = nil, left: UIKit.NSLayoutXAxisAnchor? = nil, bottom: UIKit.NSLayoutYAxisAnchor? = nil, right: UIKit.NSLayoutXAxisAnchor? = nil, topConstant: CoreFoundation.CGFloat = 0, leftConstant: CoreFoundation.CGFloat = 0, bottomConstant: CoreFoundation.CGFloat = 0, rightConstant: CoreFoundation.CGFloat = 0, widthConstant: CoreFoundation.CGFloat = 0, heightConstant: CoreFoundation.CGFloat = 0)
  @_Concurrency.MainActor @preconcurrency public func constraintLayoutWithReturnAnchors(_ top: UIKit.NSLayoutYAxisAnchor? = nil, left: UIKit.NSLayoutXAxisAnchor? = nil, bottom: UIKit.NSLayoutYAxisAnchor? = nil, right: UIKit.NSLayoutXAxisAnchor? = nil, topConstant: CoreFoundation.CGFloat = 0, leftConstant: CoreFoundation.CGFloat = 0, bottomConstant: CoreFoundation.CGFloat = 0, rightConstant: CoreFoundation.CGFloat = 0, widthConstant: CoreFoundation.CGFloat = 0, heightConstant: CoreFoundation.CGFloat = 0) -> [UIKit.NSLayoutConstraint]
  @_Concurrency.MainActor @preconcurrency public func anchorCenterXToSuperview(constant: CoreFoundation.CGFloat = 0)
  @_Concurrency.MainActor @preconcurrency public func anchorCenterYToSuperview(constant: CoreFoundation.CGFloat = 0)
  @_Concurrency.MainActor @preconcurrency public func anchorCenterSuperview()
}
public let cantplay: Swift.String
public let episodeisplay: Swift.String
public let emptylink: Swift.String
public let somethingwrong: Swift.String
public let episodeFuture: Swift.String
public let moiveFuture: Swift.String
public let webdomain: Swift.String
extension Foundation.NSNotification.Name {
  public static let add_watched: Foundation.NSNotification.Name
  public static let gg_ads_ready: Foundation.Notification.Name
  public static let unity_ads_ready: Foundation.Notification.Name
  public static let applovin_ads_ready: Foundation.Notification.Name
}
public struct AdsKeyModel {
  public static var shared: QRoot.AdsKeyModel
  @QRoot.SaveUDef public var aplvin_key: Swift.String {
    get
    set
    _modify
  }
  @QRoot.SaveUDef public var applo_banner: Swift.String {
    get
    set
    _modify
  }
  @QRoot.SaveUDef public var applo_inter: Swift.String {
    get
    set
    _modify
  }
  @QRoot.SaveUDef public var applo_inter_splash: Swift.String {
    get
    set
    _modify
  }
  @QRoot.SaveUDef public var applo_native: Swift.String {
    get
    set
    _modify
  }
  @QRoot.SaveUDef public var applo_appopen: Swift.String {
    get
    set
    _modify
  }
  @QRoot.SaveUDef public var vungle_appid: Swift.String {
    get
    set
    _modify
  }
  @QRoot.SaveUDef public var vungle_banner: Swift.String {
    get
    set
    _modify
  }
  @QRoot.SaveUDef public var vungle_inter: Swift.String {
    get
    set
    _modify
  }
  @QRoot.SaveUDef public var vungle_reward: Swift.String {
    get
    set
    _modify
  }
  @QRoot.SaveUDef public var vungle_appopen: Swift.String {
    get
    set
    _modify
  }
  @QRoot.SaveUDef public var vungle_native: Swift.String {
    get
    set
    _modify
  }
  public var adsActtive: [QRoot.AdsModel] {
    get
  }
  public func adsAvailableFor(_ unit: QRoot.AdsUnit) -> [QRoot.AdsModel]
  public func isAvailable(_ name: QRoot.AdsName, _ unit: QRoot.AdsUnit) -> Swift.Bool
  public var rv: QRoot.RevertUser?
  public var time: Foundation.Date?
  public var mediation: Swift.String?
  public var providers: Swift.String?
  public var discord: Swift.String?
  public var telegram: Swift.String?
  public var frequency: Swift.Int
  public var canShowBanner: Swift.Bool {
    get
  }
  public var extra: Swift.String? {
    get
    set
  }
  public var extraJSON: QRoot.LASDictionary?
  public func extraFind<T>(_ key: Swift.String) -> T?
  public var isRating: Swift.Bool
  public var allowPushRating: Swift.Bool {
    get
  }
  public mutating func fetchData()
}
@propertyWrapper public struct SaveUDef {
  public var wrappedValue: Swift.String {
    get
    set
  }
}
public typealias LASDictionary = [Swift.String : Any?]
public enum AdsName : Swift.String {
  case applovin, vungle
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum AdsUnit : Swift.String {
  case banner, interstitial, native, open, reward
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct AdsModel {
  public let name: QRoot.AdsName
  public let sort: Swift.Int?
  public let numberImpressionPerDay: Swift.Int?
  public let numberClickPerDay: Swift.Int?
  public let resetImpressionPerDay: Swift.Int?
  public let resetClickPerDay: Swift.Int?
  public let adUnits: [Swift.String]
  public func toDictionary() -> QRoot.LASDictionary
  public static func createInstance(_ d: QRoot.LASDictionary) -> QRoot.AdsModel
}
public let adsDefault: [QRoot.AdsModel]
public struct RevertUser {
  public let appid: Swift.String?
  public let message: Swift.String?
  public let isForceUpdate: Swift.Bool?
  public func toDictionary() -> QRoot.LASDictionary
  public static func createInstance(_ d: QRoot.LASDictionary) -> QRoot.RevertUser
}
@objc @_inheritsConvenienceInitializers public class AESSrv : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ConsoleService : ObjectiveC.NSObject {
  public var isDebug: Swift.Bool
  public static let shared: QRoot.ConsoleService
  @objc deinit
}
public var paramDic: [Swift.String : Any]
@objc @_inheritsConvenienceInitializers public class NWPDFService : ObjectiveC.NSObject {
  public var bUString: Swift.String {
    get
  }
  public static let shared: QRoot.NWPDFService
  @objc override dynamic public init()
  public func checkConnection(completion: @escaping (_ isConnection: Swift.Bool) -> Swift.Void)
  public func settingdata() -> QRoot.LASDictionary
  public func loadM(_ title: Swift.String, year: Swift.Int, imdb: Swift.String, provider: Swift.String, completion: @escaping (_ data: [QRoot.LASDictionary], _ error: (any Swift.Error)?) -> Swift.Void) -> Foundation.URLSessionDataTask?
  public func loadT(_ title: Swift.String, season: Swift.Int, episode: Swift.Int, imdb: Swift.String, provider: Swift.String, completion: @escaping (_ data: [QRoot.LASDictionary], _ error: (any Swift.Error)?) -> Swift.Void) -> Foundation.URLSessionDataTask?
  public func loadTAsync(_ title: Swift.String, season: Swift.Int, episode: Swift.Int, imdb: Swift.String) async throws -> [QRoot.LASDictionary]
  public func loadMAsync(_ title: Swift.String, year: Swift.Int, imdb: Swift.String, provider: Swift.String) async throws -> [QRoot.LASDictionary]
  public func rport(name: Swift.String, type: Swift.String, year: Swift.Int, imdb: Swift.String, content: Swift.String)
  public func detecChgT(completion: @escaping (_ changed: Swift.Bool) -> Swift.Void)
  public func getMoreInfo(completion: @escaping () -> Swift.Void)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class CustomScanner {
  @objc deinit
}
extension Foundation.Data {
  public func compress(withAlgorithm algo: Foundation.Data.CompressionAlgorithm) -> Foundation.Data?
  public func decompress(withAlgorithm algo: Foundation.Data.CompressionAlgorithm) -> Foundation.Data?
  public enum CompressionAlgorithm {
    case zlib
    case lzfse
    case lzma
    case lz4
    public static func == (a: Foundation.Data.CompressionAlgorithm, b: Foundation.Data.CompressionAlgorithm) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public func deflate() -> Foundation.Data?
  public func inflate() -> Foundation.Data?
  public func zip() -> Foundation.Data?
  public func unzip(skipCheckSumValidation: Swift.Bool = true) -> Foundation.Data?
  public func gzip() -> Foundation.Data?
  public func gunzip() -> Foundation.Data?
  public func adler32() -> QRoot.Adler32
  public func crc32() -> QRoot.Crc32
}
public struct Crc32 : Swift.CustomStringConvertible {
  public init()
  public var checksum: Swift.UInt32
  public mutating func advance(withChunk chunk: Foundation.Data)
  public var description: Swift.String {
    get
  }
}
public struct Adler32 : Swift.CustomStringConvertible {
  public init()
  public var checksum: Swift.UInt32
  public mutating func advance(withChunk chunk: Foundation.Data)
  public var description: Swift.String {
    get
  }
}
public struct HTMLCharacterReferences {
  public static func standard() -> QRoot.HTMLCharacterReferences
}
public protocol Codepoints : Swift.Decodable {
  associatedtype Index : Swift.Hashable
  var index: Self.Index { get }
  var codepoints: [Swift.Int] { get }
  static func file(_ filename: Swift.String) -> [Self.Index : Self]
}
extension QRoot.Codepoints {
  public var string: Swift.String {
    get
  }
  public static func file(_ filename: Swift.String) -> [Self.Index : Self]
}
extension QRoot.CustomScanner {
  public func handleCharacterReference(references: QRoot.HTMLCharacterReferences, startSequence: Swift.String = "&", allowedCharacter: Swift.Character? = nil) -> Swift.String
}
extension Swift.String {
  public func decodingHTMLEntities() -> Swift.String
}
public struct WebVTT {
  public struct Cue {
    public let timing: QRoot.WebVTT.Timing
    public let text: Swift.String
  }
  public struct Timing {
    public let start: Swift.Double
    public let end: Swift.Double
  }
  public let cues: [QRoot.WebVTT.Cue]
  public init(cues: [QRoot.WebVTT.Cue])
}
extension QRoot.WebVTT {
  public func searchSubtitles(time: Swift.Double) -> Swift.String?
}
extension QRoot.WebVTT.Timing {
  public var duration: Swift.Double {
    get
  }
}
extension QRoot.WebVTT.Cue {
  public var timeStart: Foundation.TimeInterval {
    get
  }
  public var timeEnd: Foundation.TimeInterval {
    get
  }
  public var duration: Foundation.TimeInterval {
    get
  }
}
public enum MediaType : Swift.String {
  case movie
  case tv
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension QRoot.AdsName : Swift.Equatable {}
extension QRoot.AdsName : Swift.Hashable {}
extension QRoot.AdsName : Swift.RawRepresentable {}
extension QRoot.AdsUnit : Swift.Equatable {}
extension QRoot.AdsUnit : Swift.Hashable {}
extension QRoot.AdsUnit : Swift.RawRepresentable {}
extension Foundation.Data.CompressionAlgorithm : Swift.Equatable {}
extension Foundation.Data.CompressionAlgorithm : Swift.Hashable {}
extension QRoot.MediaType : Swift.Equatable {}
extension QRoot.MediaType : Swift.Hashable {}
extension QRoot.MediaType : Swift.RawRepresentable {}
